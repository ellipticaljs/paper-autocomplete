<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-ripple/paper-ripple.html">
<link rel="import" href="../paper-material/paper-material.html">

<script>
  /**
   * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
   * behavior is implemented by `<paper-input>`. It exposes a number of properties from
   * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
   * template.
   *
   * The input element can be accessed by the `inputElement` property if you need to access
   * properties or methods that are not exposed.
   *
   * @polymerBehavior Polymer.PaperAutocompleteBehavior
   */
  Polymer.PaperAutocompleteBehaviorImpl = {
    is: 'paper-autocomplete',
    properties: {
      /**
       * `autoValidate` Set to true to auto-validate the input value.
       */
      autoValidate: {
        type: Boolean,
        value: false
      },

      /**
       * `errorMessage` The error message to display when the input is invalid.
       */
      errorMessage: {
        type: String,
      },

      /**
       * `label` Text to display as the input label
       */
      label: String,

      /**
       * `noLabelFloat` Set to true to disable the floating label.
       */
      noLabelFloat: {
        type: Boolean,
        value: false
      },

      /**
       * `alwaysFloatLabel` Set to true to always float label
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * `required` Set to true to mark the input as required.
       */
      required: {
        type: Boolean,
        value: false
      },

      /**
       * `source` Array of objects with the options to execute the autocomplete feature
       */
      source: Array,

      /**
       * Property of local datasource to as the text property
       */
      textProperty: {
        type: String,
        value: 'text'
      },

      /**
       * Property of local datasource to as the value property
       */
      valueProperty: {
        type: String,
        value: 'value'
      },

      /**
       * `value` Selected object from the suggestions
       */
      value: {
        type: Object,
        notify: true
      },

      /**
       * The current/selected text of the input
       */
      text: {
        type: String,
        notify: true,
        value: ''
      },

      /**
       * Disable showing the clear X button
       */
      disableShowClear: {
        type: Boolean,
        value: false
      },

      /**
       * Binds to a remote data source
       */
      remoteSource: {
        type: Boolean,
        value: false
      },

      /**
       * Event type separator
       */
      eventNamespace: {
        type: String,
        value: '-'
      },

      /**
       * Minimum length to trigger suggestions
       */
      minLength: {
        value: 1
      },

      /**
       * Indicates if shadow dom is used
       */
      useShadowDom: {
        type: Boolean,
        value: false
      },

      /**
       * `pattern` Pattern to validate input field
       */
      pattern: String,

      /**
       * allowedPattern` allowedPattern to validate input field
       */
      allowedPattern: String,

      /**
       * Set to `true` to show a character counter.
       */
      charCounter: {
        type: Boolean,
        value: false
      },

      /**
       * The maximum length of the input value.
       */
      maxlength: {
        type: Number
      },

      /**
       * `_suggestions` Array with the actual suggestions to display
       */
      _suggestions: Array,

      _currentIndex: {
        value: -1
      },
      _scrollIndex: {
        value: 0
      },
      _maxViewableItems: {
        value: 7
      },
      _itemHeight: {
        value: 36
      },
      _value: {
        value: undefined
      },
      _text: {
        value: undefined
      },

      /**
       * This value is used as a base to generate unique individual ids that need to be added to each suggestion for
       * accessibility reasons.
       */
      _idItemSeed: {
        type: String,
        value: 'aria-' + new Date().getTime() + '-' + (Math.floor(Math.random() * 1000)),
        readOnly: true
      },

      /**
       * Id of the DOM element currently highlighted
       */
      _idElementHighlighted: {
        type: String,
        value: ''
      },

      /**
       * Text value of the current highlighted value to be announce to the screen reader
       */
      _textOfHighlightedElement: {
        type: String
      },

      /**
       * `true` if the suggestions list is opened, `false otherwise`
       */
      _isSuggestionsOpened: {
        type: Boolean,
        value: false
      }
    },
    // Element Lifecycle
    ready: function () {
      this._value = this.value;
    },

    attached: function () {
      // `attached` fires once the element and its parents have been inserted
      // into a document.
      //
      // This is a good place to perform any work related to your element's
      // visual state or active behavior (measuring sizes, beginning animations,
      // loading resources, etc).
    },
    detached: function () {
      // The analog to `attached`, `detached` fires when the element has been
      // removed from a document.
      //
      // Use this to clean up anything you did in `attached`.
    },
    listeners: {
      'input.focus': '_onFocus',
      'input.blur': '_onBlur'
    },

    // Element Behavior
    /**
     * Clears the input text
     */
    _clear: function () {
      this.value = this._value;
      this.text = this._text;
      this.$.clear.style.display = 'none';
      this._hideSuggestionsWrapper();
      this._emptyItems();
      var option = {
        text: this.text,
        value: this.value
      };
      this._fireEvent(option, 'reset');
    },

    /**
     * Get the text property from the suggestion
     * @param {Object} suggestion The suggestion item
     * @return {String}
     */
    _getItemText: function (suggestion) {
      return suggestion[this.textProperty];
    },

    /**
     * Show the suggestions wrapper
     */
    _showSuggestionsWrapper: function () {
      this.$.suggestionsWrapper.style.display = 'block';
      this._isSuggestionsOpened = true;
    },

    /**
     * Hide the suggestions wrapper
     */
    _hideSuggestionsWrapper: function () {
      this.$.suggestionsWrapper.style.display = 'none';
      this._isSuggestionsOpened = false;
      this._idElementHighlighted = '';
      this._textOfHighlightedElement = '';
    },

    _handleSuggestions: function (event) {
      if (!this.remoteSource) this._createSuggestions(event);
      else this._remoteSuggestions(event);
    },

    _remoteSuggestions: function (event) {
      var value = event.target.value;
      var minLength = this.minLength;
      var option = {
        text: this.text,
        value: value
      };
      if (value && value.length >= minLength) this._fireEvent(option, 'change');
      else {
        this.$.clear.style.display = 'none';
        this._suggestions = [];
      }
    },

    _bindSuggestions: function (arr) {
      if (arr.length && arr.length > 0) {
        this._suggestions = arr;
        this._currentIndex = -1;
        this._scrollIndex = 0;
        if (!this.disableShowClear) this.$.clear.style.display = 'block';
        this._showSuggestionsWrapper();
      } else {
        this.$.clear.style.display = 'none';
        this._suggestions = [];
      }
    },

    _createSuggestions: function (event) {
      this._currentIndex = -1;
      this._scrollIndex = 0;
      var value = event.target.value;
      var minLength = this.minLength;
      if (value && value.length >= minLength) {
        value = value.toLowerCase();
        // Shows the clear button.
        if (!this.disableShowClear) this.$.clear.style.display = 'block';
        // Search for the word in the source properties.
        if (this.source && this.source.length > 0) {
          this._suggestions = [];
          var length = this.source.length;
          var objText, objValue;
          for (var i = 0; i < length; i++) {
            var item = this.source[i];
            if (typeof item === 'object') {
              objText = item[this.textProperty];
              objValue = item[this.valueProperty]
            } else {
              objText = item.toString();
              objValue = objText;
            }
            if (objText.toLowerCase().indexOf(value) === 0) {
              // Adds the item to the suggestions list.
              this.push('_suggestions', {text: objText, value: objValue});
            }
          }

          if (this._suggestions.length > 0) {
            this._showSuggestionsWrapper();
          } else {
            this._hideSuggestionsWrapper();
          }
        }
      } else {
        this.$.clear.style.display = 'none';
        this._suggestions = [];
      }
    },

    _selection: function (index) {
      var selectedOption = this._suggestions[index];
      var self = this;
      this.text = selectedOption[this.textProperty];
      this.value = selectedOption[this.valueProperty];
      this._value = this.value;
      this._text = this.text;
      this.$.clear.style.display = 'none';
      this._emptyItems();
      this._fireEvent(selectedOption, 'selected');
      setTimeout(function () {
        self._hideSuggestionsWrapper();
      }, 300);
    },

    _getItems: function () {
      var supportsShadow = Boolean(Element.prototype.createShadowRoot);
      var useShadow = this.useShadowDom;
      if (useShadow && supportsShadow) return this.shadowRoot.querySelectorAll('paper-item');
      else return this.querySelectorAll('paper-item');
    },

    _emptyItems: function () {
      this._suggestions = [];
    },

    _getId: function () {
      var id = this.getAttribute('id');
      if (!id) id = this.dataset.id;
      return id;
    },

    _removeActive: function (items) {
      for (var i = 0; i < items.length; i++) {
        items[i].classList.remove('active');
        items[i].setAttribute('aria-selected', "false");
      }
    },

    _keydown: function () {
      var items = this._getItems();
      var length = items.length;
      length--;
      if (this._currentIndex < length) {
        this._removeActive(items);
        this._currentIndex++;
        items[this._currentIndex].classList.add('active');
        items[this._currentIndex].setAttribute('aria-selected', "true");
        this._idElementHighlighted = items[this._currentIndex].id;
        this._textOfHighlightedElement = this._suggestions[this._currentIndex].text;
        this._scrollDown();
      }
    },

    _keyup: function () {
      var items = this._getItems();
      if (this._currentIndex > 0) {
        this._removeActive(items);
        this._currentIndex--;
        items[this._currentIndex].classList.add('active');
        items[this._currentIndex].setAttribute('aria-selected', "true");
        this._idElementHighlighted = items[this._currentIndex].id;
        this._textOfHighlightedElement = this._suggestions[this._currentIndex].text;
        this._scrollUp();
      }
    },

    _keyenter: function () {
      if (this.$.suggestionsWrapper.style.display == 'block' && this._currentIndex > -1) {
        var index = this._currentIndex;
        this._selection(index);
      }
    },

    _scrollDown: function () {
      var viewIndex = this._currentIndex - this._scrollIndex;
      if (viewIndex >= this._maxViewableItems) {
        this._scrollIndex++;
        var scrollTop = (this._scrollIndex * this._itemHeight);
        var paperMaterial = this.querySelector('paper-material');
        paperMaterial.scrollTop = scrollTop;
      }
    },

    _scrollUp: function () {
      var viewIndex = this._currentIndex - this._scrollIndex;
      if (viewIndex < 0) {
        this._scrollIndex--;
        var scrollTop = (this._scrollIndex * this._itemHeight);
        var paperMaterial = this.querySelector('paper-material');
        paperMaterial.scrollTop = scrollTop;
      }
    },
    _fireEvent: function (option, evt) {
      var id = this._getId();
      var event = 'autocomplete' + this.eventNamespace + evt;

      this.fire(event, {
        id: id,
        value: option[this.valueProperty] || option.value,
        text: option[this.textProperty] || option.text,
        target: this,
        option: option
      });
    },

    _onKeypress: function (event) {
      var which = event.which;
      if (which === 40) {
        this._keydown();
      } else if (which === 38) {
        this._keyup(event);
      } else if (which === 13) {
        this._keyenter();
      } else {
        this._handleSuggestions(event);
      }
    },

    _onSelect: function (event) {
      var index = event.model.index;
      this._selection(index);
    },

    _onBlur: function (event) {
      var self = this;
      var option = {
        text: this.text,
        value: this.value
      };

      this._fireEvent(option, 'blur');
      setTimeout(function () {
        self.$.clear.style.display = 'none';
        self._hideSuggestionsWrapper();
      }, 300);
    },

    _onFocus: function (event) {
      var option = {
        text: this.text,
        value: this.value
      };
      this._fireEvent(option, 'focus');
    },

    /* public */
    /**
     * Gets the current value of the input
     * @returns {String}
     */
    getValue: function () {
      return this.value;
    },

    /**
     * Gets the current text/value option of the input
     * @returns {Object}
     */
    getOption: function () {
      return {
        text: this.text,
        value: this.value
      };
    },

    /**
     * Sets the current text/value option of the input
     * @param {Object} option
     */
    setOption: function (option) {
      this.text = option.text;
      this.value = option.value;
    },

    /**
     * Disables the input
     */
    disable: function () {
      this.disabled = true;
      this.$.input.disabled = true;
    },

    /**
     * Enables the input
     */
    enable: function () {
      this.disabled = false;
      this.$.input.disabled = false;
    },

    /**
     * Sets the component's current suggestions
     * @param {Array} arr
     */
    suggestions: function (arr) {
      this._bindSuggestions(arr);
    },

    /**
     * Validates the input
     * @returns {Boolean}
     */
    validate: function () {
      return this.$.input.validate();
    },

    /**
     * Clears the current input
     */
    clear: function () {
      this._value = '';
      this._text = '';
      this._clear();
    },

    /**
     * Resets the current input
     */
    reset: function () {
      this._clear();
    },

    /**
     * Hides the suggestions popup
     */
    hideSuggestions: function () {
      var self = this;
      setTimeout(function () {
        self.$.clear.style.display = 'none';
        self._hideSuggestionsWrapper();
      }, 300);
    },

    /**
     * Generate a suggestion id for a certain index
     * @param {number} index Position of the element in the suggestions list
     * @returns {string} a unique id based on the _idItemSeed and the position of that element in the suggestions popup
     * @private
     */
    _getSuggestionId: function (index) {
      return this._idItemSeed + '-' + index;
    }

    /**
     * Fired when a selection is made
     *
     * @event autocomplete-selected
     * @param {String} id
     * @param {String} text
     * @param {Element} target
     * @param {Object} option
     */

    /**
     * Fired on input change
     *
     * @event autocomplete-change
     * @param {String} id
     * @param {String} text
     * @param {Element} target
     * @param {Object} option
     */

    /**
     * Fired on input focus
     *
     * @event autocomplete-focus
     * @param {String} id
     * @param {String} text
     * @param {Element} target
     * @param {Object} option
     */

    /**
     * Fired on input blur
     *
     * @event autocomplete-blur
     * @param {String} id
     * @param {String} text
     * @param {Element} target
     * @param {Object} option
     */

    /**
     * Fired on input reset/clear
     *
     * @event autocomplete-reset-blur
     * @param {String} id
     * @param {String} text
     * @param {Element} target
     * @param {Object} option
     */
  };

  /** @polymerBehavior */
  Polymer.PaperAutocompleteBehavior = [
    Polymer.PaperAutocompleteBehaviorImpl
  ];
</script>
